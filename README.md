# Документация для backend-разработчика: архитектура и логика работы Tea Map

## Описание проекта

**Tea Map** — это веб-приложение для отображения и добавления "спотов" (мест для чаепития) на интерактивной карте. Пользователь может просматривать карту, видеть список спотов, выбирать их на карте или в списке, а также добавлять новые.

---

## Какие файлы нужно версионировать в git

- `package.json`, `package-lock.json` или `yarn.lock` — зависимости проекта.
- `README.md` — эта документация.
- `next.config.js`, `tsconfig.json` — конфигурация Next.js и TypeScript.
- Все файлы исходного кода:
  - `/components/` — React-компоненты (например, `ClientMap.tsx`).
  - `/lib/` — вспомогательные модули, типы, утилиты (например, `spots.ts`).
  - `/pages/` или `/app/` — страницы Next.js и API-роуты.
  - `/public/` — только статические файлы, необходимые для работы приложения (например, favicon, иконки, статические изображения, которые нужны всем пользователям).
  - `/styles/` — стили, если используются.
- `.env.example` — пример файла переменных окружения (без секретных данных).
- `.gitignore` — правила игнорирования файлов.

---

## Что НЕ нужно коммитить

- `node_modules/` — устанавливается через npm/yarn.
- `.next/`, `out/`, `dist/` — артефакты сборки.
- `logs/`, `*.log` — логи.
- `public/uploads/`, большие медиафайлы, временные файлы, дампы, базы данных, кэш, coverage, tmp, temp и т.п.
- `.env`, `.env.local`, `.env.*` — реальные переменные окружения с секретами.

---

## Пример структуры репозитория

```
/components/
  ClientMap.tsx
/lib/
  spots.ts
/pages/ или /app/
  (страницы и API-роуты)
/public/
  favicon.ico
  tea-icon.svg
  (другие необходимые статики)
/styles/
  (если есть)
/README.md
/package.json
/package-lock.json
/yarn.lock
/tsconfig.json
/next.config.js
/.gitignore
/.env.example
```

---

## Для backend-разработчика

- Все исходники, конфиги, документация и пример env должны быть в git.
- Всё, что генерируется автоматически или может быть восстановлено (node_modules, .next, dist, временные и тяжелые файлы) — не коммитить.

---

## Архитектура и основные компоненты

### 1. Frontend (Next.js + React + TypeScript)

- **Next.js** — фреймворк для Node.js, который позволяет писать серверный и клиентский код на React. Серверная часть работает на Node.js, клиентская — в браузере.
- **React** — UI-фреймворк, компоненты которого рендерятся как на сервере (SSR), так и на клиенте.
- **Leaflet** — JS-библиотека для отображения карты и маркеров (работает только на клиенте).
- **TypeScript** — строгая типизация данных и компонентов.

### 2. Основные файлы и их назначение

#### `/components/ClientMap.tsx`

- Главный компонент, отвечающий за отображение карты, списка спотов и взаимодействие пользователя.
- Содержит:
  - **Header** — шапка с логотипом и кнопкой "Случайный спот".
  - **SpotList** — список всех спотов слева.
  - **Leaflet Map** — карта с маркерами спотов справа.
- Взаимодействие:
  - Клик по маркеру или элементу списка центрирует карту на споте и открывает карточку.
  - Кнопка "Случайный спот" выбирает случайный спот, центрирует карту и открывает карточку.
  - Клик по карте вызывает функцию добавления нового спота.

#### `/lib/spots.ts`

- Описание типа данных `Spot` (id, name, description, longDescription, image, lat, lng, created_at).
- Пример массива спотов для тестирования.

---

## Технические детали и жизненный цикл данных

### 1. Инициализация и рендеринг

- **Next.js** запускается на Node.js, рендерит страницу на сервере (SSR) и отдает HTML клиенту.
- После загрузки страницы, React-компоненты "оживают" на клиенте (hydration).
- Компонент `ClientMap` помечен как `'use client'`, чтобы работать только на клиенте (иначе Leaflet не будет работать на сервере Node.js).

### 2. Работа с картой (Leaflet)

- Карта создается внутри useEffect, чтобы избежать SSR-конфликтов.
- Контейнер для карты — обычный `<div>`, в который Leaflet монтирует карту.
- Маркеры создаются динамически для каждого спота.
- Для каждого маркера навешивается обработчик клика, который:
  - Центрирует карту на маркере (анимировано).
  - После завершения анимации вызывает callback для открытия карточки спота.

### 3. Список спотов

- Список реализован как отдельный компонент, отображается слева.
- Клик по элементу списка вызывает аналогичную логику: центрирует карту и открывает карточку.

### 4. Кнопка "Случайный спот"

- Находится в шапке.
- При нажатии выбирает случайный спот, центрирует карту и открывает карточку.

### 5. Добавление нового спота

- Клик по пустой области карты вызывает функцию onMapClick(lat, lng).
- Обычно это открывает форму для добавления нового спота (реализуется на уровне приложения).

---

## Взаимодействие с backend (Node.js API)

### Что требуется реализовать на Node.js:

1. **REST API для спотов**
   - GET `/api/spots` — возвращает массив объектов Spot.
   - POST `/api/spots` — принимает данные нового спота, возвращает созданный объект Spot.
   - GET `/api/spots/:id` — возвращает один спот по id.

2. **API для загрузки изображений**
   - POST `/api/upload` — принимает файл, сохраняет его (например, в S3 или локально), возвращает URL.

3. **Требования к данным**
   - Все поля Spot должны быть валидированы на сервере.
   - id генерируется на сервере (UUID).
   - created_at выставляется на сервере (ISO-строка).

4. **Пример структуры Spot**

```json
{
  "id": "uuid",
  "name": "Название",
  "description": "Краткое описание",
  "longDescription": "Детальное описание",
  "image": "https://...",
  "lat": 55.7522,
  "lng": 37.6156,
  "created_at": "2024-05-01T12:00:00Z"
}
```

---

## Логика обмена данными (пошагово)

1. **Получение спотов**
   - При загрузке страницы фронтенд делает GET-запрос к `/api/spots`.
   - Сервер (Node.js) возвращает массив Spot.

2. **Добавление спота**
   - Пользователь кликает по карте, открывает форму, отправляет данные через POST `/api/spots`.
   - Сервер валидирует, сохраняет, возвращает новый Spot.
   - Фронтенд обновляет список спотов.

3. **Загрузка изображения**
   - Файл отправляется через POST `/api/upload`.
   - Сервер сохраняет файл, возвращает URL.
   - URL сохраняется в поле image нового Spot.

4. **Выбор спота**
   - Клик по маркеру или списку вызывает onMarkerClick(spot) — открывается карточка.

---

## Как интегрировать с backend

1. **Заменить мок-данные из `/lib/spots.ts` на реальные данные из API.**
2. **Передавать функции для обработки событий (onMarkerClick, onMapClick) из родительского компонента, где реализована логика работы с backend.**
3. **Обеспечить хранение и отдачу изображений по URL.**
4. **Обеспечить уникальность id для каждого спота (например, через UUID на сервере).**
5. **Обеспечить CORS, если фронтенд и backend на разных доменах.**

---

## Важные детали Node.js

- **Node.js** — это среда выполнения JS вне браузера, используется для серверной логики (API, SSR).
- **Next.js** использует Node.js для серверного рендеринга и API-роутов (файлы в `/pages/api` или `/app/api`).
- **API-роуты** — обычные функции-обработчики, экспортируемые из файлов, принимают (req, res) и работают как Express middleware.
- **Асинхронность** — все операции с БД и файлами должны быть асинхронными (Promise/async/await).
- **Валидация** — используйте библиотеки типа `zod` или `joi` для проверки данных.
- **Работа с файлами** — для загрузки файлов используйте `multer` или аналоги, для хранения — локально или в облаке.

---

## Схема взаимодействия

1. **Пользователь открывает страницу** → Получает список спотов с backend.
2. **Пользователь кликает по карте** → Открывается форма добавления спота → POST на backend → обновление списка.
3. **Пользователь кликает по маркеру или списку** → Карта центрируется → открывается карточка спота.
4. **Пользователь нажимает "Случайный спот"** → Выбирается случайный спот → карта центрируется → открывается карточка.

---

## Пример API-роута на Next.js (Node.js)

```typescript
// pages/api/spots.ts
import type { NextApiRequest, NextApiResponse } from 'next';
import { v4 as uuidv4 } from 'uuid';

let spots: Spot[] = []; // Можно заменить на работу с БД

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method === 'GET') {
    res.status(200).json(spots);
  } else if (req.method === 'POST') {
    const { name, description, longDescription, image, lat, lng } = req.body;
    const newSpot = {
      id: uuidv4(),
      name,
      description,
      longDescription,
      image,
      lat,
      lng,
      created_at: new Date().toISOString(),
    };
    spots.push(newSpot);
    res.status(201).json(newSpot);
  } else {
    res.status(405).end();
  }
}
```

---

## Для вопросов и интеграции

- Основная логика взаимодействия с backend реализуется в родительском компоненте, который передает данные и обработчики в `ClientMap`.
- Все функции обратного вызова (onMarkerClick, onMapClick) должны быть реализованы с учетом асинхронной работы с API.
- Для сложных сценариев (авторизация, фильтрация, пагинация) — расширяйте API по аналогии.

---
